# calculate
用位运算模拟CPU的加减乘除
一、计算机加法的实现：
(1).一位二进制加法
首先给出一位二进制加法的真值表，然后我们通过分析真值表来得出如果进行二进制加法的规则。
一位二进制加法真值表:(对应于硬件中的半加器)
x 	y 	sum	carry

0	0	0	0

0	1	1	0

1	0	1	0

1	1	0	1

分析上面一位二进制加法的真值表，可以看出和其实就是x XOR y的结果。而进位恰好是x AND y的结果。下面提供XOR和AND的真值表，进行验证。
 
x XOR y真值表:
x 	y 	output

0	0	0

0	1	1

1	0	1

1	1	0

x AND y真值表:
x 	y 	output

0	0	0

0	1	0

1	0	0

1	1	1

(2).多位二进制加法
因此进行一位二进制加法，只要对x和y进行XOR和AND运算就可以得出和以及进位。如果要求多位的二进制加法，则要把低位传上来的进位也要计算进去。修改一位二进制加法的真值表，在输入部分中加入低位传入的进位，然后对计算结果进行修正就可以得到多位二进制加法的真值表了。
 
多位二进制加法真值表：(对应于硬件中的全加器)
x 	y 	icarry 	sum	ocarry

0	0	0		0	0

0	0	1		1	0

0	1	0		1	0

0	1	1		0	1

1	0	0		1	0

1	0	1		0	1

1	1	0		0	1

1	1	1		1	1

分析上面的真值表就可以总结出，多位二进制加法的规则了。如下：
sum = (x XOR y) XOR icarry
ocarry = (x AND y) OR (icarry AND (x XOR y)) = (x AND y) OR (y AND icarry) OR (icarry AND x)
 
利用以上的分析结果，可将x, y的每一位级联计算，先计算x和y的第零位，该位的输入进位(icarry=0)为零，将计算所得的进位传入到x和y的第一位的计算中，依次进行直到计算完最高位为止，此时将每一位计算所得的和连接起来就是最终的和，最高位计算所得的进位就是最终的进位。至此，二进制的加法应该没有什么问题了，很简单XOR为和，AND为进位。计算机中的加法也是使用这种原理来实现的，有兴趣的可以看看《编码的奥秘》这本书。
 
(3).实现加法
通过以上分析似乎用代码实现计算机加法的方法已经很明了了，将参加计算的x,y分别一位一位的进行XOR和AND，然后将结果打印出来，OK完事了，很简单不是吗？但问题是如果将x和y的每一位拆分，然后记录每一位计算后所得的进位，然后做为下一位的进位输入。仔细想想又似乎是问题多多啊，烦啊。其实也不然我们用代码实现的时候已经不需要再将每一位拆分计算了(如果你确实像模拟计算机硬件的执行过程也可以这么做，只是这样做很麻烦，而且计算的速度比较慢)。首先，我们通过对x和y进行&位运算，得出每一位上的进位。然后对x和y进行^位运算，得出没有加进位的和。最后将所得的和当做新的x，所得的进位往左移一位(第零位的进位输入为0)当做新的y，继续做上面的步骤，直到进位为0，此时x中保存的就是我们要求的x和y的和了。
具体的实现代码也很简单。

二、计算机减法的实现
(1).减法概述
减法是加法的逆运算，加法中有进位，相应的减法中需要借位。加法中的进位可以从低位开始依次往上传递，而且高位对低位的计算不产生影响。而减法的借位，则需要从高位获得，高位会对低位的计算产生影响。如果是小数字减大数字则计算过程更复杂，因此直接实现减法对计算机来说很复杂，而且效率很低。那计算机要如何实现减法呢？也许你们听说过2-补码，这就是计算机要施展的魔法，摇身一变，很难实现的减法运算将变成加法。然后直接利用上一节实现的加法过程完成计算。什么是补码？取反运算就是最简单的补码。2-补码比取反多了一个步骤，即取反后加1。还是用实例来说话吧。下面是8位(即一个字节)的2-补码编码以及所表示的数字，一个字节能表示从-128到127的数字。如果要更详细的了解2-补码那就看这里。
 
二进制		十进制
10000000	-128

10000001	-127

10000010	-126

10000011	-125

.
.
.
11111101	-3

11111110	-2

11111111	-1

00000000	0

00000001	1

00000010	2

.
.
.
01111100	124

01111101	125

01111110	126

01111111	127
 
通过上面的表，不难看出只要想得到一个数的相反数，只要对这个数求2-补码就可以了，即取反加1操作。然后继续对得到的结果进行该操作就可以得到原来的数字。通过使用2-补码形式的编码，我们可以把减法运算顺利的转换成加法。只要对减数求2-补码，然后跟被减数相加即可得到差值。不信，那就验证一下 例如 124 - 127 = -3 。我们利用上面的规则来进行验证一下，先算出减数的2-补码，减数为127，对其求2-补码后为-127(10000001)。然后跟124(01111100)执行加法操作。即可获得我们需要的差值 01111100 + 10000001 = 11111101(-3)刚好获得的结果就是-3的编码。这里就不举更多的例子了，有兴趣的可以自己验证。
 
(2).减法的实现
通过上面的研究，要在代码中实现减法已经很明了，很简单了。第一步对减数取反然后加1，第二步将第一步所得值和被减数相加。
 
三、计算机乘法的实现
(1).原始的乘法实现
乘法最简单的理解就是，将被乘数加乘数次即可得到乘积。考虑到负整数的乘法，我们这里先对乘数和被乘数求绝对值，然后对绝对值进行上述的乘法操作。确定乘积符号的规则为同号为正，异号为负。

(2).改进的乘法实现
上面的第一种实现方式虽然简单，但是效率太低。如果乘数和被乘数小一点还可以，如果大了那效率是不能忍受的。这里要实现的这种乘法，最多做log(n)次的加法操作，就可以求出乘积。这种方式和第一方式的相同点是，这里也是先对两数的绝对值就乘积，最后确定符号。这种实现方式就是对手动计算乘数的模拟。具体步骤如下：
1)根据乘数每一位为1还是为0，决定相加数取被乘数移位后的值还是取0；
2)各相加数从乘数的最低位开始求值，并逐次将相加数(被乘数)左移一位，最后一步求和
3)符号位根据同号为正异号为负的原则
如果对上面的步骤还很难明白的话，那我下面举个简单的例子。对照着例子然后在仔细分析下上面的计算步骤，将不难明白这种实现方式的原理。例如 11 * 13 = 143 ，转换成二进制 1011 * 1101 =10001111 ，首先判断乘数的第一位，这里第一位为1，因此第一个相加数为1101。然后判断乘数的第二位，这里第二位为1，所以第二个相加数为11010，即被乘数左移一位。继续看乘数的第三位，这里第三位为0，则第三个相加数为0。最后看乘数的第四位，这里为1，所以最后一个相加数为1101000即被乘数左移三位。最后将获得的所有相加数都加起来，而这个和就是所要求的乘积。我们验证一下是否正确，将我们算出的各个相加数依次加起来。(1101+11010+0+1101000=10001111)哦，果然和上面给出的一样，我们把二进制转成十进制即为143。不难看出来相加数就是根据乘数的第n位是否为1，如果为1，就将被乘数左移n位所得(这里n从0开始)。
 
计算过程演示： 
           1 0 1 1
*          1 1 0 1
 ------------------
           1 1 0 1
         1 1 0 1 0
       0 0 0 0 0 0
     1 1 0 1 0 0 0
 ------------------
   1 0 0 0 1 1 1 1

四、计算机除法的实现
(1).原始的除法实现
最简单的除法实现就是不停的用除数去减被除数，直到被除数小于除数时，此时所减的次数就是我们需要的商，而此时的被除数就是余数。唯一需要注意的就是商的符号和余数的符号。商的符号确定方式也乘法是一样，即同号为正，异号为负。而余数的符号和被除数的符号是一样的。和简单的乘法实现一样，这里我们要先对两数的绝对值求商，求余数。最后再确定符号。

(2).改进的除法实现
在改进乘法的时候我们是从乘法的手动计算入手的，然后根据手动计算总结乘法的规律，最后动手实现。这里我不进行手动计算除法的分析。只给出相对应的算法描述：
 
首先对被除数和除数求绝对值，下面的过程中用到的除数和被除数都是求过绝对值的数值。
0)设定invert为2，即二进制10。
1)如果被除数大于0则将被除数的第一位与invert进行或运算，否则转到3)继续。
2)然后对invert左移一位，被除数右移一位。转到1)继续。
3)余数左移一位，并将最后一位置为invert的最后一位。invert右移一位。
4)商左移一位，如果余数大于除数，则从余数中减去除数，并把商的最后一位置1。
5)如果invert等于1则返回商，否则转到3)继续。
符号确定规则，与上面的简单实现方式相同。上面算法中唯一比较疑惑的就是为什么要用invert而不是直接用被除数，同时为什么要设定invert的初始值为2呢？如果你对除法的手动计算进行过分析的话，细心的你也许已经发现了模拟过程中的一个难点。那就是怎么从被除数的最高位开始，然后每一步都往低位逐渐移动。如果不用任何技巧而直接从最低位开始一直寻找到最高位也是可行的，但是这样的话就必须要知道你现在所用的整形是多少位的。为了避免这个问题我就把被除数反序表示。这样的话用完被除数最高位，只要将invert右移一位，原来的次高位很容的就变成了现在的最高位，从而大大简化了计算过程。不要高兴的太早，这样处理虽然是可行的但是又会引出另外一个问题，比如1100， 如果我用反序表示就是0011。Oh my god!如果最低位是0的数字进行反序后，这些0被自动丢弃了。那么如果不让它们丢弃呢？解决方法就在于invert初始化为2，即反序的最高位我置为1，这样的话，我在右移后判断下invert是否为1就知道当前位是否为被除数的最后一位了。OK，啰嗦了这么多我自己已经彻底搞蒙了，不知道看的人是不是会更加糊涂哦。

五、后记
我实现的都是最简单的整数运算，浮点型以及更复杂类型的没有实现。虽然实现的比较简单，但是我觉得原理已经都说清楚了，至少我自己认为说的比较详细了。
